<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pizarra Táctica de Fútbol Profesional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --brand-blue: #2563eb;
            --brand-red: #dc2626;
            --brand-green: #16a34a;
            --brand-yellow: #f59e0b;
            --gray-900: #111827;
            --gray-800: #1f2937;
            --gray-700: #374151;
            --toolbar-height: 120px; /* Adjusted for two rows */
        }
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--gray-900);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 1rem;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 105 / 78; /* Standard pitch ratio + toolbar space */
        }
        .tool-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border: none;
            outline: none;
        }
        .tool-btn:focus-visible {
            box-shadow: 0 0 0 3px var(--brand-blue);
        }
        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .tool-btn.active {
            background-color: var(--brand-blue);
            color: white;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.15);
        }
        .color-swatch.active {
            border-color: white;
            box-shadow: 0 0 0 3px var(--brand-blue);
        }
        canvas {
            touch-action: none;
            cursor: default;
        }
        .modal-backdrop {
            transition: opacity 0.2s ease-in-out;
        }
        .modal-content {
            transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
            transform: scale(0.95);
            opacity: 0;
        }
        .modal-backdrop:not(.hidden) .modal-content {
            transform: scale(1);
            opacity: 1;
        }
        #toolbar {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            width: calc(100% - 2rem);
            max-width: 90rem;
            z-index: 10;
            transform: translateX(-50%) translateY(calc(100% + 1rem));
            transition: transform 0.3s ease-in-out;
        }
        #canvas-container.toolbar-visible #toolbar {
            transform: translateX(-50%) translateY(0);
        }
        #toggle-toolbar {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 20;
            transition: transform 0.3s ease-in-out, background-color 0.2s;
        }
        #canvas-container.toolbar-visible #toggle-toolbar {
            transform: translateY(calc(-1 * var(--toolbar-height) - 16px));
        }
    </style>
</head>
<body>

    <div id="canvas-container" class="relative bg-[#067a3e] shadow-2xl rounded-lg overflow-hidden">
        <canvas id="tactical-board" class="w-full h-full"></canvas>

        <div id="toolbar" class="bg-gray-800/80 backdrop-blur-sm p-3 rounded-lg shadow-2xl flex flex-col items-center gap-2">
            <!-- Toolbar Row 1 -->
            <div class="flex flex-wrap justify-center items-center gap-3">
                <!-- Field Type Dropdown -->
                <div class="relative" id="field-type-dropdown">
                    <button id="field-type-button" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md flex items-center gap-2 flex-shrink-0">
                        <i data-lucide="rectangle-horizontal" class="w-5 h-5"></i>
                        <span id="field-type-label" class="text-sm font-medium">Campo Completo</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                    </button>
                    <div id="field-type-options" class="absolute bottom-full mb-2 w-48 bg-gray-700 rounded-md shadow-lg hidden z-20">
                        <a href="#" data-type="full" class="flex items-center gap-2 px-4 py-2 text-sm text-white hover:bg-gray-600 rounded-t-md"><i data-lucide="rectangle-horizontal" class="w-5 h-5"></i> Campo Completo</a>
                        <a href="#" data-type="half" class="flex items-center gap-2 px-4 py-2 text-sm text-white hover:bg-gray-600"><i data-lucide="rectangle-vertical" class="w-5 h-5"></i> Medio Campo</a>
                        <a href="#" data-type="blank" class="flex items-center gap-2 px-4 py-2 text-sm text-white hover:bg-gray-600 rounded-b-md"><i data-lucide="square" class="w-5 h-5"></i> Campo Vacío</a>
                    </div>
                </div>
                <div class="h-8 border-l border-gray-600"></div>
                
                <!-- Players & Objects -->
                <button id="add-player-red" class="tool-btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md" title="Añadir Jugador Rojo">+ Rojo</button>
                <button id="add-player-blue" class="tool-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md" title="Añadir Jugador Azul">+ Azul</button>
                <div class="h-8 border-l border-gray-600"></div>
                <button id="add-ball" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Balón"><i data-lucide="dribbble" class="w-5 h-5"></i></button>
                <button id="add-cone" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Cono"><svg class="w-5 h-5" viewBox="0 0 24 24"><path fill="#f97316" d="M12 2L2 22h20L12 2z"/></svg></button>
                <button id="add-cone-stick" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Cono con Pica"><svg class="w-5 h-5" viewBox="0 0 24 24"><path fill="#f97316" d="M12 12L2 22h20L12 12z"/><path stroke="#a1a1aa" stroke-width="2" d="M12 2v10"/></svg></button>
                <div class="relative">
                     <button id="add-marker" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Seta/Marcador"><svg class="w-5 h-5" viewBox="0 0 24 24"><path fill="#16a34a" d="M2 12h20v2H2zM12 2a10 10 0 00-8 4h16a10 10 0 00-8-4z"/></svg></button>
                     <div id="marker-color-picker" class="absolute bottom-full mb-2 bg-gray-700 p-2 rounded-md shadow-lg flex gap-2 hidden opacity-0 z-20">
                         <div class="color-swatch" style="background-color: #16a34a;" data-color="#16a34a"></div>
                         <div class="color-swatch" style="background-color: #2563eb;" data-color="#2563eb"></div>
                         <div class="color-swatch" style="background-color: #facc15;" data-color="#facc15"></div>
                         <div class="color-swatch" style="background-color: #dc2626;" data-color="#dc2626"></div>
                     </div>
                </div>
                <button id="add-hurdle" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Valla"><i data-lucide="grip-horizontal" class="w-5 h-5 text-orange-500"></i></button>
                <button id="add-goal" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Portería"><i data-lucide="goal" class="w-5 h-5"></i></button>
                <button id="add-mini-goal" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-full" title="Añadir Mini Portería"><i data-lucide="goal" class="w-4 h-4"></i></button>
                <div class="h-8 border-l border-gray-600"></div>

                <!-- Editing Tools -->
                <button id="select-tool" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Seleccionar y Mover"><i data-lucide="mouse-pointer-2" class="w-5 h-5"></i></button>
                <button id="selection-box-tool" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Selección de Área"><i data-lucide="square-dashed-mouse-pointer" class="w-5 h-5"></i></button>
                <button id="draw-arrow" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Dibujar Flecha Continua"><i data-lucide="arrow-up-right" class="w-5 h-5"></i></button>
                <button id="draw-dashed-arrow" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Dibujar Flecha Discontinua"><i data-lucide="arrow-up-right" class="w-5 h-5 opacity-50"></i></button>
                <button id="draw-pencil" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Dibujo Libre (Lápiz)"><i data-lucide="pencil" class="w-5 h-5"></i></button>
                <button id="delete-tool" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Borrar Elemento Seleccionado"><i data-lucide="trash-2" class="w-5 h-5"></i></button>
            </div>
            <!-- Toolbar Row 2 -->
            <div class="flex flex-wrap justify-center items-center gap-3">
                <button id="undo-btn" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Deshacer"><i data-lucide="undo-2" class="w-5 h-5"></i></button>
                <button id="redo-btn" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Rehacer"><i data-lucide="redo-2" class="w-5 h-5"></i></button>
                <div class="h-8 border-l border-gray-600"></div>
                
                <!-- Size Controls -->
                <button id="scale-down" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Empequeñecer Elementos"><i data-lucide="zoom-out" class="w-5 h-5"></i></button>
                <button id="scale-up" class="tool-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md" title="Agrandar Elementos"><i data-lucide="zoom-in" class="w-5 h-5"></i></button>
                <div class="h-8 border-l border-gray-600"></div>
                
                <!-- Color Palette -->
                <div id="color-palette" class="flex gap-2 items-center">
                    <div class="color-swatch active" style="background-color: #1e40af;" data-color="#1e40af"></div>
                    <div class="color-swatch" style="background-color: #facc15;" data-color="#facc15"></div>
                    <div class="color-swatch" style="background-color: #ef4444;" data-color="#ef4444"></div>
                    <div class="color-swatch" style="background-color: #ffffff;" data-color="#ffffff"></div>
                </div>
                <div class="h-8 border-l border-gray-600 flex-shrink-0"></div>
                
                <!-- Board Actions -->
                <div class="flex items-center gap-2 flex-shrink-0">
                     <button id="export-image" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md flex items-center gap-2" title="Exportar como imagen"><i data-lucide="download" class="w-4 h-4"></i> Exportar</button>
                     <button id="clear-drawings-btn" class="tool-btn bg-yellow-600 hover:bg-yellow-700 text-white p-2 rounded-md" title="Borrar solo los dibujos"><i data-lucide="eraser" class="w-5 h-5"></i></button>
                     <button id="clear-board" class="tool-btn bg-red-800 hover:bg-red-900 text-white p-2 rounded-md" title="Limpiar todo el tablero"><i data-lucide="x-square" class="w-5 h-5"></i></button>
                </div>
            </div>
        </div>

        <button id="toggle-toolbar" class="tool-btn bg-gray-800 hover:bg-gray-700 p-2 rounded-full shadow-lg" title="Mostrar/Ocultar barra de herramientas">
            <i data-lucide="panel-bottom-open" class="w-6 h-6"></i>
        </button>
    </div>

    <!-- Modals -->
    <div id="confirmation-modal" class="modal-backdrop fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-30">
        <div class="modal-content bg-gray-800 rounded-lg p-6 shadow-xl w-11/12 max-w-sm text-center">
            <p id="modal-text" class="mb-6 text-lg">¿Estás seguro?</p>
            <div class="flex justify-center gap-4">
                <button id="modal-cancel" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-md">Cancelar</button>
                <button id="modal-confirm" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-6 rounded-md">Confirmar</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas & Context Setup ---
            const canvas = document.getElementById('tactical-board');
            const ctx = canvas.getContext('2d');

            // --- State Management ---
            let state = {
                elements: [],
                history: [],
                historyIndex: -1,
                selectedElements: [],
                draggingState: null,
                rotatingElement: null,
                drawing: false,
                currentPath: null,
                currentTool: 'select',
                currentDrawColor: '#1e40af',
                elementScale: 0.8,
                currentFieldType: 'full',
                selectionRect: null
            };

            // --- Constants ---
            const ROTATE_ICON_PATH = new Path2D("M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L12 12h9V3l-3.26 3.26A9.96 9.96 0 0 0 12 2a10 10 0 1 0 10 10z");

            // --- History (Undo/Redo) Logic ---
            const saveState = () => {
                state.history = state.history.slice(0, state.historyIndex + 1);
                state.history.push(JSON.stringify(state.elements));
                state.historyIndex++;
                updateUndoRedoButtons();
            };

            const undo = () => {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    state.elements = JSON.parse(state.history[state.historyIndex]);
                    state.selectedElements = [];
                    redrawAll();
                    updateUndoRedoButtons();
                }
            };

            const redo = () => {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    state.elements = JSON.parse(state.history[state.historyIndex]);
                    state.selectedElements = [];
                    redrawAll();
                    updateUndoRedoButtons();
                }
            };

            const updateUndoRedoButtons = () => {
                document.getElementById('undo-btn').disabled = state.historyIndex <= 0;
                document.getElementById('redo-btn').disabled = state.historyIndex >= state.history.length - 1;
            };

            // --- Canvas Sizing & Drawing ---
            const resizeCanvas = () => {
                const container = document.getElementById('canvas-container');
                const { width, height } = container.getBoundingClientRect();
                canvas.width = width;
                canvas.height = height;
                redrawAll();
            };

            const drawField = () => {
                ctx.fillStyle = '#067a3e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                switch (state.currentFieldType) {
                    case 'full': drawFullField(); break;
                    case 'half': drawHalfField(); break;
                    // 'blank' requires no extra drawing
                }
            };
            
            // --- Field Drawing Functions ---
            const drawFullField = () => {
                const w = canvas.width, h = canvas.height;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = Math.max(1.5, w * 0.002);
                
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath();
                ctx.moveTo(w / 2, 0);
                ctx.lineTo(w / 2, h);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(w / 2, h / 2, w * 0.08, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.strokeRect(0, h * 0.2, w * 0.15, h * 0.6);
                ctx.strokeRect(w * 0.85, h * 0.2, w * 0.15, h * 0.6);
                ctx.strokeRect(0, h * 0.35, w * 0.07, h * 0.3);
                ctx.strokeRect(w * 0.93, h * 0.35, w * 0.07, h * 0.3);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                [w * 0.5, w * 0.12, w * 0.88].forEach(x => {
                    ctx.beginPath();
                    ctx.arc(x, h/2, w*0.004, 0, 2*Math.PI);
                    ctx.fill();
                });
            };

            const drawHalfField = () => {
                const w = canvas.width, h = canvas.height;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = Math.max(1.5, w * 0.002);
                const fieldW = w;
                const fieldH = w * (52.5 / 68);
                const offsetY = h - fieldH;
                const paW = (40.32 / 68) * fieldW;
                const paH = (16.5 / 52.5) * fieldH;
                ctx.strokeRect((fieldW - paW) / 2, offsetY + fieldH - paH, paW, paH);
                const gaW = (18.32 / 68) * fieldW;
                const gaH = (5.5 / 52.5) * fieldH;
                ctx.strokeRect((fieldW - gaW) / 2, offsetY + fieldH - gaH, gaW, gaH);
                const penaltySpotY = offsetY + fieldH - ((11 / 52.5) * fieldH);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(fieldW / 2, penaltySpotY, w * 0.004, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, offsetY);
                ctx.lineTo(w, offsetY);
                ctx.stroke();
                const centerCircleRadius = (9.15 / 68) * fieldW;
                ctx.beginPath();
                ctx.arc(w / 2, offsetY, centerCircleRadius, 0, Math.PI);
                ctx.stroke();
            };

            // --- Element Drawing Functions ---
            const drawElement = (el) => {
                const drawFns = {
                    'player': drawPlayer, 'arrow': drawArrow, 'pencil': drawPencil,
                    'cone': drawCone, 'cone-stick': drawConeWithStick, 'ball': drawBall,
                    'hurdle': drawHurdle, 'goal': drawGoal, 'mini-goal': drawGoal,
                    'marker': drawMarker
                };
                if (drawFns[el.type]) drawFns[el.type](el);
            };
            
            const drawPlayer = (player) => {
                const radius = player.radius * state.elementScale;
                if (state.selectedElements.includes(player)) {
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, radius + 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.fill();
                }
                ctx.beginPath();
                ctx.arc(player.x, player.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = player.textColor;
                ctx.font = `bold ${radius * 0.9}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(player.text, player.x, player.y);
            };
            
            const drawArrow = (arrow) => {
                const headlen = 12 * state.elementScale;
                const dx = arrow.endX - arrow.startX, dy = arrow.endY - arrow.startY;
                const angle = Math.atan2(dy, dx);
                
                ctx.save();
                if (state.selectedElements.includes(arrow)) {
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.lineWidth = (4 * state.elementScale) + 10;
                    ctx.lineCap = 'round';
                    if (arrow.style === 'dashed') ctx.setLineDash([10 * state.elementScale, 10 * state.elementScale]);
                    ctx.beginPath();
                    ctx.moveTo(arrow.startX, arrow.startY);
                    ctx.lineTo(arrow.endX, arrow.endY);
                    ctx.stroke();
                }

                ctx.strokeStyle = arrow.color;
                ctx.lineWidth = 4 * state.elementScale;
                ctx.lineCap = 'round';
                if (arrow.style === 'dashed') ctx.setLineDash([10 * state.elementScale, 10 * state.elementScale]);
                
                ctx.beginPath();
                ctx.moveTo(arrow.startX, arrow.startY);
                ctx.lineTo(arrow.endX, arrow.endY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(arrow.endX, arrow.endY);
                ctx.lineTo(arrow.endX - headlen * Math.cos(angle - Math.PI / 6), arrow.endY - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(arrow.endX, arrow.endY);
                ctx.lineTo(arrow.endX - headlen * Math.cos(angle + Math.PI / 6), arrow.endY - headlen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();

                if (state.selectedElements.length === 1 && state.selectedElements[0] === arrow) {
                    const handlePos = getRotationHandle(arrow);
                    ctx.resetTransform();
                    ctx.translate(handlePos.x, handlePos.y);
                    ctx.fillStyle = '#3b82f6';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.scale(0.6, 0.6);
                    ctx.translate(-12, -12);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill(ROTATE_ICON_PATH);
                }
                ctx.restore();
            };

            const drawPencil = (path) => {
                if (path.points.length < 2) return;
                ctx.save();
                if (state.selectedElements.includes(path)) {
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.lineWidth = (3 * state.elementScale) + 10;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    for (let i = 1; i < path.points.length; i++) {
                        ctx.lineTo(path.points[i].x, path.points[i].y);
                    }
                    ctx.stroke();
                }

                ctx.strokeStyle = path.color;
                ctx.lineWidth = 3 * state.elementScale;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    ctx.lineTo(path.points[i].x, path.points[i].y);
                }
                ctx.stroke();
                ctx.restore();
            };
            
            const drawBall = (ball) => {
                const radius = ball.radius * state.elementScale;
                if (state.selectedElements.includes(ball)) {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, radius + 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.fill();
                }
                ctx.save();
                ctx.translate(ball.x, ball.y);
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = Math.max(1, radius * 0.1);
                ctx.stroke();
                ctx.restore();
            };

            const drawRotatableElement = (el, drawFn) => {
                ctx.save();
                ctx.translate(el.x, el.y);
                ctx.rotate(el.angle);
                drawFn();
                if (state.selectedElements.includes(el)) {
                    const width = el.width * state.elementScale;
                    const height = el.height * state.elementScale;
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-width / 2 - 3, -height / 2 - 3, width + 6, height + 6);
                    
                    if (state.selectedElements.length === 1) {
                        const handlePos = getRotationHandle(el);
                        ctx.save();
                        ctx.resetTransform();
                        ctx.translate(handlePos.x, handlePos.y);
                        ctx.fillStyle = '#3b82f6';
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 10, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        ctx.save();
                        ctx.scale(0.6, 0.6);
                        ctx.translate(-12, -12);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill(ROTATE_ICON_PATH);
                        ctx.restore();
                        ctx.restore();
                    }
                }
                ctx.restore();
            };

            const drawCone = (cone) => drawRotatableElement(cone, () => {
                const w = cone.width * state.elementScale, h = cone.height * state.elementScale;
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(-w / 2, h / 2);
                ctx.lineTo(w / 2, h / 2);
                ctx.closePath();
                ctx.fillStyle = '#f97316';
                ctx.fill();
            });

            const drawConeWithStick = (cone) => drawRotatableElement(cone, () => {
                const w = cone.width * state.elementScale, h = cone.height * state.elementScale;
                ctx.beginPath();
                ctx.moveTo(0, h * 0.1);
                ctx.lineTo(-w / 2, h / 2);
                ctx.lineTo(w / 2, h / 2);
                ctx.closePath();
                ctx.fillStyle = '#f97316';
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, h * 0.1);
                ctx.lineTo(0, -h/2);
                ctx.strokeStyle = '#a1a1aa';
                ctx.lineWidth = 4 * state.elementScale;
                ctx.stroke();
            });

            const drawHurdle = (hurdle) => drawRotatableElement(hurdle, () => {
                const w = hurdle.width * state.elementScale, h = hurdle.height * state.elementScale;
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 4 * state.elementScale;
                ctx.beginPath();
                ctx.moveTo(-w / 2, h / 2);
                ctx.lineTo(-w / 2, -h / 2);
                ctx.lineTo(w / 2, -h / 2);
                ctx.lineTo(w / 2, h / 2);
                ctx.stroke();
            });
            
            const drawGoal = (goal) => drawRotatableElement(goal, () => {
                const w = goal.width * state.elementScale, h = goal.height * state.elementScale;
                ctx.strokeStyle = '#e5e5e5';
                ctx.lineWidth = 4 * state.elementScale;
                ctx.strokeRect(-w / 2, -h / 2, w, h);
            });

            const drawMarker = (marker) => drawRotatableElement(marker, () => {
                const w = marker.width * state.elementScale;
                ctx.beginPath();
                ctx.arc(0, 0, w / 2, Math.PI, 2 * Math.PI);
                ctx.closePath();
                ctx.fillStyle = marker.color;
                ctx.fill();
            });
            
            const drawSelectionRect = () => {
                if (!state.selectionRect) return;
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.lineWidth = 1;
                const { startX, startY, endX, endY } = state.selectionRect;
                ctx.fillRect(startX, startY, endX - startX, endY - startY);
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            };
            
            const redrawAll = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawField();
                state.elements.forEach(drawElement);
                drawSelectionRect();
            };

            // --- Element Creation ---
            const addElement = (type, options = {}) => {
                let pos = { x: canvas.width / 2, y: canvas.height / 2 };
                if (type.startsWith('player')) {
                    pos.x = Math.random() * (canvas.width * 0.9) + (canvas.width * 0.05);
                    pos.y = Math.random() * (canvas.height * 0.9) + (canvas.height * 0.05);
                }

                let newElement;
                const baseWidth = canvas.width;

                switch (type) {
                    case 'player-red':
                    case 'player-blue': {
                        const color = type === 'player-red' ? '#dc2626' : '#2563eb';
                        const count = state.elements.filter(p => p.type === 'player' && p.color === color).length + 1;
                        newElement = { type: 'player', x: pos.x, y: pos.y, radius: baseWidth * 0.02, color, textColor: '#ffffff', text: count.toString() };
                        break;
                    }
                    case 'ball':
                        newElement = { type: 'ball', x: pos.x, y: pos.y, radius: baseWidth * 0.012 };
                        break;
                    case 'cone':
                        newElement = { type: 'cone', x: pos.x, y: pos.y, width: baseWidth * 0.025, height: baseWidth * 0.025, angle: 0 };
                        break;
                    case 'cone-stick':
                        newElement = { type: 'cone-stick', x: pos.x, y: pos.y, width: baseWidth * 0.025, height: baseWidth * 0.05, angle: 0 };
                        break;
                    case 'marker':
                        newElement = { type: 'marker', x: pos.x, y: pos.y, width: baseWidth * 0.03, height: baseWidth * 0.015, angle: 0, color: options.color || '#16a34a' };
                        break;
                    case 'hurdle':
                        newElement = { type: 'hurdle', x: pos.x, y: pos.y, width: baseWidth * 0.05, height: baseWidth * 0.025, angle: 0 };
                        break;
                    case 'goal':
                        newElement = { type: 'goal', x: pos.x, y: pos.y, width: baseWidth * 0.15, height: baseWidth * 0.05, angle: 0 };
                        break;
                    case 'mini-goal':
                        newElement = { type: 'mini-goal', x: pos.x, y: pos.y, width: baseWidth * 0.08, height: baseWidth * 0.03, angle: 0 };
                        break;
                }

                if (newElement) {
                    state.elements.push(newElement);
                    state.selectedElements = [newElement];
                    saveState();
                    redrawAll();
                    setActiveTool('select');
                }
            };

            // --- Event Handling ---
            const getEventPos = (evt) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.touches?.[0]?.clientX;
                const clientY = evt.clientY ?? evt.touches?.[0]?.clientY;
                return {
                    x: (clientX - rect.left) * (canvas.width / rect.width),
                    y: (clientY - rect.top) * (canvas.height / rect.height)
                };
            };
            
            const getRotationHandle = (el) => {
                if (!el) return null;
                if (el.hasOwnProperty('angle')) { // For cones, goals, etc.
                     const handleOffset = -el.height * state.elementScale / 2 - 20;
                    return { 
                        x: el.x + handleOffset * Math.sin(el.angle), 
                        y: el.y - handleOffset * Math.cos(el.angle), 
                        radius: 10 
                    };
                }
                if (el.type === 'arrow') {
                    const handleOffset = 25;
                    const angle = Math.atan2(el.endY - el.startY, el.endX - el.startX);
                    return {
                        x: el.endX + handleOffset * Math.cos(angle),
                        y: el.endY + handleOffset * Math.sin(angle),
                        radius: 10
                    }
                }
                return null;
            };

            const isPointInside = (element, pos) => {
                const scale = state.elementScale;
                const HIT_THRESHOLD = 10 * scale;

                if (element.type === 'player' || element.type === 'ball') {
                    return Math.hypot(pos.x - element.x, pos.y - element.y) < element.radius * scale * 1.5;
                }
                if (element.hasOwnProperty('angle')) {
                    const dx = pos.x - element.x, dy = pos.y - element.y;
                    const rotatedX = dx * Math.cos(-element.angle) - dy * Math.sin(-element.angle);
                    const rotatedY = dx * Math.sin(-element.angle) + dy * Math.cos(-element.angle);
                    return Math.abs(rotatedX) < (element.width * scale / 2) && Math.abs(rotatedY) < (element.height * scale / 2);
                }
                if (element.type === 'arrow') {
                    const { startX: x1, startY: y1, endX: x2, endY: y2 } = element;
                    const { x: px, y: py } = pos;
                    const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
                    if (l2 === 0) return Math.hypot(px - x1, py - y1) < HIT_THRESHOLD;
                    let t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2));
                    return Math.hypot(px - (x1 + t * (x2 - x1)), py - (y1 + t * (y2 - y1))) < HIT_THRESHOLD;
                }
                 if (element.type === 'pencil') {
                    for (let i = 0; i < element.points.length - 1; i++) {
                        const { x: x1, y: y1 } = element.points[i];
                        const { x: x2, y: y2 } = element.points[i + 1];
                        const { x: px, y: py } = pos;
                        const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
                        if (l2 === 0) {
                            if (Math.hypot(px - x1, py - y1) < HIT_THRESHOLD) return true;
                            continue;
                        }
                        let t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2));
                        const dist = Math.hypot(px - (x1 + t * (x2 - x1)), py - (y1 + t * (y2 - y1)));
                        if (dist < HIT_THRESHOLD) return true;
                    }
                }
                return false;
            };

            const handleMouseDown = (e) => {
                e.preventDefault();
                const pos = getEventPos(e);
                
                if (state.currentTool === 'selection-box') {
                    state.selectionRect = { startX: pos.x, startY: pos.y, endX: pos.x, endY: pos.y };
                    return;
                }

                const handle = (state.selectedElements.length === 1) ? getRotationHandle(state.selectedElements[0]) : null;
                if (handle && Math.hypot(pos.x - handle.x, pos.y - handle.y) < handle.radius * 1.5) {
                    state.rotatingElement = state.selectedElements[0];
                    return;
                }

                const clickedElement = [...state.elements].reverse().find(el => isPointInside(el, pos));
                
                if (clickedElement) {
                    if (!state.selectedElements.includes(clickedElement)) {
                        state.selectedElements = [clickedElement];
                    }
                    state.draggingState = {
                        initialMousePos: pos,
                        initialElements: JSON.parse(JSON.stringify(state.selectedElements))
                    };
                } else {
                    state.selectedElements = [];
                    if (state.currentTool.startsWith('draw')) {
                        state.drawing = true;
                        const commonProps = { color: state.currentDrawColor };
                        if (state.currentTool.includes('arrow')) {
                            state.currentPath = { ...commonProps, type: 'arrow', style: state.currentTool.includes('dashed') ? 'dashed' : 'solid', startX: pos.x, startY: pos.y, endX: pos.x, endY: pos.y };
                        } else if (state.currentTool === 'draw-pencil') {
                            state.currentPath = { ...commonProps, type: 'pencil', points: [pos] };
                        }
                        if(state.currentPath) state.elements.push(state.currentPath);
                    }
                }
                redrawAll();
            };

            const handleMouseMove = (e) => {
                e.preventDefault();
                const pos = getEventPos(e);

                if (state.selectionRect) {
                    state.selectionRect.endX = pos.x;
                    state.selectionRect.endY = pos.y;
                } else if (state.draggingState) {
                    const dx = pos.x - state.draggingState.initialMousePos.x;
                    const dy = pos.y - state.draggingState.initialMousePos.y;
                    state.selectedElements.forEach((el, index) => {
                        const initialEl = state.draggingState.initialElements[index];
                        if (el.hasOwnProperty('x')) { // Movable objects
                            el.x = initialEl.x + dx;
                            el.y = initialEl.y + dy;
                        } else if (el.type === 'arrow') {
                            el.startX = initialEl.startX + dx;
                            el.startY = initialEl.startY + dy;
                            el.endX = initialEl.endX + dx;
                            el.endY = initialEl.endY + dy;
                        } else if (el.type === 'pencil') {
                            el.points = initialEl.points.map(p => ({ x: p.x + dx, y: p.y + dy }));
                        }
                    });
                } else if (state.rotatingElement) {
                    const el = state.rotatingElement;
                    if (el.hasOwnProperty('angle')) { // Standard rotatable objects
                         el.angle = Math.atan2(pos.y - el.y, pos.x - el.x) + Math.PI / 2;
                    } else if (el.type === 'arrow') {
                        const cx = (el.startX + el.endX) / 2;
                        const cy = (el.startY + el.endY) / 2;
                        const length = Math.hypot(el.endX - el.startX, el.endY - el.startY);
                        const newAngle = Math.atan2(pos.y - cy, pos.x - cx);
                        el.startX = cx - (length / 2) * Math.cos(newAngle);
                        el.startY = cy - (length / 2) * Math.sin(newAngle);
                        el.endX = cx + (length / 2) * Math.cos(newAngle);
                        el.endY = cy + (length / 2) * Math.sin(newAngle);
                    }
                } else if (state.drawing && state.currentPath) {
                    if (state.currentPath.type === 'arrow') {
                        state.currentPath.endX = pos.x;
                        state.currentPath.endY = pos.y;
                    } else if (state.currentPath.type === 'pencil') {
                        state.currentPath.points.push(pos);
                    }
                }
                redrawAll();
            };

            const handleMouseUp = (e) => {
                e.preventDefault();
                if (state.selectionRect) {
                    const { startX, startY, endX, endY } = state.selectionRect;
                    const rect = { x1: Math.min(startX, endX), y1: Math.min(startY, endY), x2: Math.max(startX, endX), y2: Math.max(startY, endY) };
                    state.selectedElements = state.elements.filter(el => {
                        if (el.hasOwnProperty('x')) {
                            return el.x >= rect.x1 && el.x <= rect.x2 && el.y >= rect.y1 && el.y <= rect.y2;
                        }
                        if (el.type === 'arrow') {
                            const startIn = el.startX >= rect.x1 && el.startX <= rect.x2 && el.startY >= rect.y1 && el.startY <= rect.y2;
                            const endIn = el.endX >= rect.x1 && el.endX <= rect.x2 && el.endY >= rect.y1 && el.endY <= rect.y2;
                            return startIn || endIn;
                        }
                        if (el.type === 'pencil') {
                            return el.points.some(p => p.x >= rect.x1 && p.x <= rect.x2 && p.y >= rect.y1 && p.y <= rect.y2);
                        }
                        return false;
                    });
                    state.selectionRect = null;
                    setActiveTool('select');
                    redrawAll();
                } else if (state.drawing || state.draggingState || state.rotatingElement) {
                    saveState();
                }
                state.draggingState = null;
                state.rotatingElement = null;
                state.drawing = false;
                state.currentPath = null;
            };

            const handleDoubleClick = (e) => {
                const pos = getEventPos(e);
                const targetPlayer = [...state.elements].reverse().find(el => el.type === 'player' && isPointInside(el, pos));
                if (targetPlayer) {
                    const newText = prompt("Introduce el nuevo número o texto:", targetPlayer.text);
                    if (newText !== null && newText.trim() !== "") {
                        targetPlayer.text = newText;
                        saveState();
                        redrawAll();
                    }
                }
            };

            // --- Modal Logic ---
            const setupModal = (modalId) => {
                const modal = document.getElementById(modalId);
                const confirmBtn = modal.querySelector('#modal-confirm');
                const cancelBtn = modal.querySelector('#modal-cancel');
                let onConfirm = null;

                const show = (text, callback) => {
                    modal.querySelector('#modal-text').textContent = text;
                    onConfirm = callback;
                    modal.classList.remove('hidden');
                    setTimeout(() => modal.querySelector('.modal-content').classList.remove('opacity-0', 'scale-95'), 10);
                };
                const hide = () => {
                    modal.querySelector('.modal-content').classList.add('opacity-0', 'scale-95');
                    setTimeout(() => modal.classList.add('hidden'), 200);
                };
                
                confirmBtn?.addEventListener('click', () => {
                    if (onConfirm) onConfirm();
                    hide();
                });
                cancelBtn?.addEventListener('click', hide);
                return { show, hide };
            };
            const confirmationModal = setupModal('confirmation-modal');

            // --- UI & Tool Management ---
            const setActiveTool = (tool) => {
                state.currentTool = tool;
                document.querySelectorAll('#toolbar .tool-btn').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.querySelector(`[id^="${tool}"]`);
                if(activeBtn) activeBtn.classList.add('active');
                
                if (!['select', 'selection-box'].includes(tool)) {
                    state.selectedElements = [];
                    redrawAll();
                }
                canvas.style.cursor = tool.startsWith('draw') ? 'crosshair' : 'default';
            };

            const setFieldType = (type, force = false) => {
                if (state.currentFieldType === type) return;
                const change = () => {
                    state.currentFieldType = type;
                    const option = document.querySelector(`#field-type-options a[data-type="${type}"]`);
                    document.getElementById('field-type-label').textContent = option.textContent.trim();
                    const iconHTML = option.querySelector('i, svg').outerHTML;
                    document.querySelector('#field-type-button > i, #field-type-button > svg').outerHTML = iconHTML;
                    lucide.createIcons();
                    state.elements = [];
                    state.selectedElements = [];
                    saveState();
                    redrawAll();
                };
                if (state.elements.length > 0 && !force) {
                    confirmationModal.show('Cambiar el tipo de campo limpiará la pizarra. ¿Continuar?', change);
                } else {
                    change();
                }
            };
            
            // --- Event Listeners Setup ---
            const setupEventListeners = () => {
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mouseleave', handleMouseUp);
                canvas.addEventListener('dblclick', handleDoubleClick);
                canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
                canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
                canvas.addEventListener('touchend', handleMouseUp);
                canvas.addEventListener('touchcancel', handleMouseUp);
                
                document.getElementById('add-player-red').addEventListener('click', () => addElement('player-red'));
                document.getElementById('add-player-blue').addEventListener('click', () => addElement('player-blue'));
                document.getElementById('add-ball').addEventListener('click', () => addElement('ball'));
                document.getElementById('add-cone').addEventListener('click', () => addElement('cone'));
                document.getElementById('add-cone-stick').addEventListener('click', () => addElement('cone-stick'));
                document.getElementById('add-hurdle').addEventListener('click', () => addElement('hurdle'));
                document.getElementById('add-goal').addEventListener('click', () => addElement('goal'));
                document.getElementById('add-mini-goal').addEventListener('click', () => addElement('mini-goal'));

                document.getElementById('select-tool').addEventListener('click', () => setActiveTool('select'));
                document.getElementById('selection-box-tool').addEventListener('click', () => setActiveTool('selection-box'));
                document.getElementById('draw-arrow').addEventListener('click', () => setActiveTool('draw-arrow'));
                document.getElementById('draw-dashed-arrow').addEventListener('click', () => setActiveTool('draw-dashed-arrow'));
                document.getElementById('draw-pencil').addEventListener('click', () => setActiveTool('draw-pencil'));
                
                document.getElementById('delete-tool').addEventListener('click', () => {
                    if(state.selectedElements.length > 0) {
                        state.elements = state.elements.filter(el => !state.selectedElements.includes(el));
                        state.selectedElements = [];
                        saveState();
                        redrawAll();
                    }
                });

                document.getElementById('undo-btn').addEventListener('click', undo);
                document.getElementById('redo-btn').addEventListener('click', redo);

                document.getElementById('scale-up').addEventListener('click', () => { state.elementScale = Math.min(2.0, state.elementScale + 0.1); redrawAll(); });
                document.getElementById('scale-down').addEventListener('click', () => { state.elementScale = Math.max(0.2, state.elementScale - 0.1); redrawAll(); });

                document.querySelectorAll('#color-palette .color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', () => {
                        state.currentDrawColor = swatch.dataset.color;
                        document.querySelectorAll('#color-palette .color-swatch').forEach(s => s.classList.remove('active'));
                        swatch.classList.add('active');
                    });
                });
                
                const markerPicker = document.getElementById('marker-color-picker');
                document.getElementById('add-marker').addEventListener('click', (e) => {
                    e.stopPropagation();
                    markerPicker.classList.toggle('hidden');
                    setTimeout(() => markerPicker.classList.toggle('opacity-0'), 10);
                });
                document.querySelectorAll('#marker-color-picker .color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        addElement('marker', { color: e.currentTarget.dataset.color });
                        markerPicker.classList.add('hidden', 'opacity-0');
                    });
                });
                
                const fieldTypeDropdown = document.getElementById('field-type-dropdown');
                const fieldTypeOptions = document.getElementById('field-type-options');
                document.getElementById('field-type-button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    fieldTypeOptions.classList.toggle('hidden');
                });
                
                document.querySelectorAll('#field-type-options a').forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.preventDefault();
                        setFieldType(e.currentTarget.dataset.type);
                        fieldTypeOptions.classList.add('hidden');
                    });
                });

                document.getElementById('clear-board').addEventListener('click', () => {
                    confirmationModal.show('¿Seguro que quieres limpiar todo el tablero?', () => {
                        state.elements = [];
                        state.selectedElements = [];
                        saveState();
                        redrawAll();
                    });
                });
                document.getElementById('clear-drawings-btn').addEventListener('click', () => {
                    confirmationModal.show('¿Seguro que quieres borrar todos los dibujos?', () => {
                        state.elements = state.elements.filter(el => !['arrow', 'pencil'].includes(el.type));
                        saveState();
                        redrawAll();
                    });
                });
                document.getElementById('export-image').addEventListener('click', () => {
                    state.selectedElements = [];
                    redrawAll();
                    const link = document.createElement('a');
                    link.download = 'pizarra-tactica.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                });
                
                const canvasContainer = document.getElementById('canvas-container');
                const toggleToolbarBtn = document.getElementById('toggle-toolbar');
                toggleToolbarBtn.addEventListener('click', () => {
                    canvasContainer.classList.toggle('toolbar-visible');
                    const icon = toggleToolbarBtn.querySelector('i, svg');
                    const isVisible = canvasContainer.classList.contains('toolbar-visible');
                    const newIcon = document.createElement('i');
                    newIcon.setAttribute('data-lucide', isVisible ? 'panel-bottom-open' : 'panel-bottom-close');
                    newIcon.classList.add('w-6', 'h-6');
                    icon.replaceWith(newIcon);
                    lucide.createIcons();
                });
                
                document.addEventListener('click', (e) => {
                    if (!fieldTypeDropdown.contains(e.target)) {
                        fieldTypeOptions.classList.add('hidden');
                    }
                    if (!document.getElementById('add-marker').parentElement.contains(e.target)) {
                        markerPicker.classList.add('hidden', 'opacity-0');
                    }
                });
            };

            // --- Initialization ---
            const init = () => {
                lucide.createIcons();
                resizeCanvas();
                saveState();
                updateUndoRedoButtons();
                setActiveTool('select');
                setupEventListeners();
                document.getElementById('canvas-container').classList.add('toolbar-visible');
            };

            init();
        });
    </script>
</body>
</html>
